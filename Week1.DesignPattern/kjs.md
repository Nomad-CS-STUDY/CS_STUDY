## minji-h

### CORS는 무엇이고, CORS 에러를 방지하려면 어떻게 해야하나요?

CORS는 교차 출처 리소스 공유 라고 말하는데 다른 출처 자원 공유라고 하는게 더 이해하기 쉽습니다.
웹에서 작동하는 클라이언트 어플리케이션은 사용자의 공격에 너무 취약합니다. 단적으로 코딩을 모르는 사람이라도, 개발자 도구만 열면 우리가 클라이언트 화면을 만들기 위해
어떠한 코드를 작성했는지 쉽게 볼 수 있죠. 이러한 문제를 방지하기 위해서 브라우저는 다른 출처 간의 통신을 제한하고 같은 출처 간의 통신만 허용하는데 이를 CORS라고 하며, 이 규약을 어겼을 때 발생하는 것이 CORS 에러입니다.
여기서 같은 출처란 URL 구성 요소 중 protocol(http://, https://), host(www.google.com, www.naver.com), port(:80, :400)가 일치하는 경우를 말합니다.

CORS 에러를 해결하기 위해서는 개발자 도구의 Network 창에서 볼 수 있는 "Access-Control-Allow-Origin" 이라는 값에, 이 리소스에 접근 가능한 출처를 명시해주어야 합니다.
프론트에서도 개발 환경에서 이를 임의로 허용해 주거나, nginx 같은 proxy server에 명시해 줄 수는 있지만 가장 좋은 방법은 서버 코드 내에서 처리해주는 것입니다.

### React의 Virtual DOM은 무엇인가요?

기존의 웹 서비스에서는 화면을 렌더링할 때 html DOM 트리가 돔을 그려서 이를 보여주고, dom에 변화가 생기면 직접적으로 업데이트를 하였습니다.
하지만 웹 서비스의 규모가 커질수록 dom 트리가 커지가 되고, dom을 직접 업데이트해서 모든 dom 노드를 다시 렌더링하는 경우 많은 비용이 드는 문제가 발생합니다.
Virtual DOM은 실제 DOM 트리가 아닌, 가상의 DOM 트리를 구성하고 이를 기존의 dom 트리와 비교하여 달라진 부분만 업데이트 해주기 때문에 비용 측면에서 많은 이점이 발생합니다.

---

## dog

### 이터레이터 패턴을 사용하는 이유는 무엇인가?

이터레이터 패턴은 iterator(반복자)를 사용하여 컬렉션의 요소들에 접근하는 디자인 패턴입니다.
컬렉션은 여러 원소들을 저장하고 관리할 수 있는 자료구조로 리스트, 맵, 배열 등 뿐만 아니라 트리, 그래프, 해시맵 등 고급 자료구조 역시 포합됩니다.

객체지향 프로그래밍에서는 내부 구현을 숨기고, 외부에는 인터페이스만 제공하는 것을 좋은 설계 원칙으로 여깁니다.
반복자 패턴은 컬렉션 내부 표현을 숨기고, 내부 구조에 대한 지식 없이 안전하게 컬렉션의 요소들에 접근할 수 있도록 도와줍니다.

### 이터레이터 패턴의 단점은?

만약 복잡한 컬렉션이 아닌 단순한 컬렉션들만 사용하는 경우, 이터레이터 패턴은 비용 증가로 이어집니다.

---

## hyewon

### 프록시 서버가 필요한 이유에 대해 설명해주세요.

- 보안: 클라이언트의 실제 ip 주소를 숨겨서 해킹을 막아줍니다.
- 캐싱: 최근에 서버에 요청된 데이터의 복사본을 캐시 메모리에 저장해두어, 사용자의 동일한 요청에 빠르게 응답 가능합니다.
- 제한: 특정 웹사이트나 서비스에 대한 접근을 사용하거나 허용할 수 있습니다. CORS 오류를 해결하는 데 사용되기도 합니다.
- 부하 분산: 여러 웹 서버로 트래픽을 분산시켜서 서버의 부하를 줄여줄 수 있습니다.
- 로그 : 사용자의 로그를 기록하여 분석할 수 있습니다.
- 그 외: 특정 웹 서버에서 제공하는 강력한 기능들 ex. Nginx로 node.js의 버퍼오버플로우 해결, CloudFlare의 DDOS 공격 방어나 HTTPS 구축

### 의존성 주입의 설명 및 장단점에 대해 설명해주세요.

의존성 주입이란 객체 지향 프로그래밍에서 의존성을 관리하는 방법입니다.
의존성은 종속성이라고도 불리며 A가 B에 의존성이 있다는 것은 B의 변경 사항에 대해 A 역시 변경되어야 한다는 것을 의미합니다.
의존성 주입은 서로 다른 모듈이 직접적으로 연결되는 것이 아니라 의존성 주입자가 이 역학을 대신하여 간접적으로 의존성을 주게 되는 방식입니다.

의존성 주입을 사용하게 되면 장점으로는

- 모듈 간의 의존성이 줄어들어, 유연하고 확장성 있는 시스템을 구축할 수 있습니다.
- 모듈을 쉽게 교체할 수 있어서 테스팅하기 쉽고 마이그레이션 또한 용이해 집니다.
- 모듈 간의 의존 관계가 명확해 지면서, 프로그램의 구조를 파악하기 쉬워집니다.

단점으로는

- 모듈들이 더욱 더 분리되기 때문에 클래스 수가 늘어나서 복잡성이 증가될 수 있습니다.
- 실행할 때 약간의 런타임 패널티가 발생할 수 있습니다.(조금 느려질 수 있습니다).

---

## yeop222

### factory pattern에 대해 설명하시오.

팩토리 패턴은 부모 클래스에서 객체를 생성할 수 있는 인터페이스를 제공하고, 자식 클래스들이 생성될 객체들의 유형을 변경할 수 있는 패턴입니다.
예를 들어 카페 라는 부모 클래스에서 음료 인터페이스를 생성할 때 자식 클래스인 카푸치노는 음료-카푸치노를, 연유커피는 음료-연유커피를 생성합니다.

상위 클래스와 하위 클래스가 분리되어 있기 때문에 느슨한 곃바을 가지며, 코드를 리팩터링 하더라도 한 곳만 고칠 수 있게 되니 유지 보수성이 증가합니다.

### factory pattern의 단점에 대해 설명하시오.

패턴을 구현하기 위해 더 많은 클래스들을 만들어야 하므로 복잡성이 증가할 수 있습니다.
