## MIZ

### 아래 코드의 시간복잡도는 무엇인가요?

바깥쪽 반복문과 안쪽 반복문 총 두개의 반복문으로 이루어져있습니다. 바깥쪽 반복문은 N번 반복하고, 안쪽 반복문은 i의 값에 따라 반복 횟수가 달라집니다. i는 0부터 n-1까지 변하며, 안쪽 반복문은 해당하는 i만큼 반복하므로 0+1+2+...+n-1로 n\*(n-1)/2번 반복합니다. 최대 차항만 계수 없이 표기하면 되므로 결과적으로 O(n^2)입니다.

### 아래 코드의 시간복잡도를 구하는 방법을 설명해주세요

i가 반복될수록 2로 나눠지기 때문에 주어진 n에 대해 log2n번만 실행됩니다. 그러므로 O(log2n)입니다.

---

## js

### 아래 코드의 시간 복잡도는 무엇일까요?

바깥쪽 반복문은 n번 반복하고 안쪽 반복문은 2배씩 증가되면서 n번 반복합니다. 2의 거듭제곱으로 증가하므로 log2n번 반복됩니다. 결론적으로 O(log2n)과 O(n)이 겹쳐진 것으로 O(n\*log2n)인 것을 알 수 있습니다.

### 시간 복잡도를 코드가 동작하는 시간이 아니라, 연산 횟수를 측정하는 이유는 무엇일까요?

코드가 동작하는 시간은 컴퓨터의 하드웨어 또는 프로그래밍 언어에 따라 편차가 달라지기 때문에 명령어의 연산 횟수 수치로 판별합니다.

---

## yeop222

### 시간 복잡도와 공간 복잡도의 차이점에 대해 설명해주세요

시간 복잡도는 알고리즘이 문제를 해결하는데 걸리는 시간의 양을 나타냅니다. 입력 크기에 대한 함수로 표현되며 빅오 표기법으 사용합니다. 좋은 알고리즘은 작은 입력에서도 빠르게 실행되고, 입력이 커져도 효율적으로 처리할 수 있어야 합니다. 공간 복잡도는 알고리즘이 실행되는 동안 사용되는 메모리 양을 나타냅니다. 입력 크기에 대한 함수로 표현되며 시간 복잡도와 같은 표기법인 빅오 표기법을 사용합니다. 좋은 알고리즘은 적은 메모리를 사용하여 원하는 결과를 얻을 수 있어야 합니다. 결론적으로, 시간 복잡도는 실행 시간에 대한 것이고, 공간 복잡도는 메모리 사용에 대한 것입니다.

### n이 커질 수록 효율적인 순서로 나열해 주세요

### O(n∗log[n]), O(1), O(log[n]), O(2ⁿ), O(n!), O(n), O(n²)

O(1)이 가장 효율적이며 O(log[n]), O(n), O(n∗log[n]), O(n²), O(2ⁿ), O(n!)순으로 효율적입니다.
