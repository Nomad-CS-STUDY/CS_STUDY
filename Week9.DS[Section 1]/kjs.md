## MIZ

### 시간복잡도
질문에 적힌 이중 for문에서 내부에 for문은 바깥에 변수 n에 의존적입니다.
1~n까지의 합은 n(n+1) / 2 입니다. 안쪽에 있는 for문에서 변수 j는 0이상 n-1미만의 범위를 지니기 때문에
(n-1)n /2 입니다.
이를 시간복잡도로 계산하면 O(n2)입니다.


### 시간복잡도를 구하는 방법
위의 코드는 i(=N)가 0보다 클 때, i 값을 a에 더하고 i를 2로 나눈 몫을 i에 다시 할당하는 while 반복문입니다.
그래프를 그려보았을 때 i값이 증가해도 그래프는 O(n)보다 작기 때문에 O(logn)의 시간복잡도를 가집니다.

## hyewon

### 빅오 계산하는 방법을 설명하세요.
보통 시간 복잡도를 생각할 때, 평균과 최악의 시간 복잡도를 고려하면서 사용합니다.
- 시간 복잡도에서 알고리즘에 가장 크게 영향을 미치는 항을 선택합니다.
- 가장 영향력 있는 항을 제외한 나머지 요소들을 제거합니다.
- 가장 영향력 있는 항에서 상수를 제거합니다.

### 시간복잡도가 높은 경우 취할 수 있는 일반 전략을 3가지 정도 설명해주실 수 있을까요?

- 이미 최적화된 표준 라이브러리 내장 함수를 사용
- 재귀 함수 대신 루프를 사용
- 반복문 내에서 계산할 필요가 없는 연산(변한지 않는 연산 값)의 경우는 외부에서 계산

## yeop222

### 시간 복잡도와 공간 복잡도의 차이점에 대해 설명해주세요

시간 복잡도는 알고리즘이 실행되는 동안 사용된 연산 횟수를 나타내는데 사용되며 보통 빅오 표기법으로 나타냅니다. 시간 복잡도는 우리가 코드를 효율적인
코드로 개선하는데 쓰이는 척도로 사용됩니다.

공간 복잡도는 알고리즘이 실행되는 데 필요한 메모리 공간의 양을 나타냅니다. 코딩테스트에서는 메모리 제한이 숨겨져 있거나, 호출 시 차지하는 메모리 공간까지 계산하기는 어렵습니다. 때문에 메모리가 차지하는 공간만 계산하고, 이 공간의 크기를 1000만 이내로 추정하여 코드를 작성하게 됩니다.

### n이 커질 수록 효율적인 순서로 나열해 주세요
O(1), O(log[n]), O(n), O(n∗log[n]), O(n²), O(2ⁿ), O(n!)