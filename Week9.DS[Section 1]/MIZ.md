## Hyewon

### 빅오 계산하는 방법을 설명하세요.

빅오를 계산하는 기본적인 방법은 다음과 같습니다:

기본 단계 찾기:

알고리즘에서 수행되는 기본 단계를 찾습니다. 기본 단계는 알고리즘이 수행하는 가장 기본적인 연산 또는 단계를 의미합니다.
입력 크기 정의:

알고리즘이 해결하는 문제의 입력 크기를 정의합니다. 일반적으로 입력 크기는 변수로 표현되며, 이를 보통 'n'으로 나타냅니다.
기본 단계 실행 횟수 계산:

입력 크기에 따라 기본 단계가 실행되는 횟수를 계산합니다. 이를 알고리즘의 실행 시간 또는 메모리 사용량과 연결짓습니다.
빅오 표기 정의:

알고리즘의 실행 시간 또는 메모리 사용량이 입력 크기 'n'에 대해 어떻게 증가하는지 나타내는 함수를 찾습니다. 이 함수를 빅오 표기법으로 나타냅니다.
계수 및 상수 무시:

빅오 표기법에서는 주로 가장 큰 항만을 고려하므로 계수와 상수를 무시합니다. 예를 들어, O(2n)은 O(n)으로 간주됩니다.
최악의 경우 고려:

빅오는 주로 최악의 경우에 대한 상한을 나타내므로, 알고리즘의 최악의 경우에 대한 실행 시간이나 메모리 사용량을 고려합니다.


### 시간복잡도가 높은 경우 취할 수 있는 일반 전략을 3가지 정도 설명해주실 수 있을까요?

1. 해결해야할 문제 또는 이슈에 맞는 적절한 알고리즘을 설계하라.
2. 알고리즘마다 핸들링 가능한 적절한 문제해결 케이스가 있기 때문에 외워두고 있거나 참고자료를 참고한다면 시간복잡도를 낮출 수 있다.
3. 각 알고리즘의 형태에 맞는 효율적인 자료구조 들을 이용한다면 시간 복잡도를 낮출 수 있다

---

## yeop222

### 시간 복잡도와 공간 복잡도의 차이점에 대해 설명해주세요

시간 복잡도(Time Complexity)와 공간 복잡도(Space Complexity)는 알고리즘의 성능을 측정하고 분석하는 데 사용되는 두 가지 주요 지표입니다.

시간 복잡도 (Time Complexity):

알고리즘이 입력 크기에 대해 실행 시간이 어떻게 증가하는지를 나타냅니다.
특히, 입력 크기가 커질 때 알고리즘의 수행 시간이 어떻게 증가하는지를 나타내는 함수로 표현됩니다.
일반적으로 "Big O" 표기법을 사용하여 나타내며, 최악의 경우에 대한 상한을 나타냅니다. 예를 들어, O(n)은 입력 크기 n에 대해 선형 시간 복잡도를 의미합니다.
공간 복잡도 (Space Complexity):

알고리즘이 실행되는 동안 사용하는 메모리 공간의 양을 나타냅니다.
특히, 입력 크기에 대한 추가적인 메모리 사용량이 어떻게 증가하는지를 나타냅니다.
마찬가지로 "Big O" 표기법을 사용하여 나타내며, 최악의 경우에 대한 상한을 나타냅니다. 예를 들어, O(1)은 상수 크기의 메모리를 사용하는 공간 복잡도를 의미합니다.


### n이 커질 수록 효율적인 순서로 나열해 주세요

### O(n∗log[n]), O(1), O(log[n]), O(2ⁿ), O(n!), O(n), O(n²)

O(1)이 가장 효율적이며 O(log[n]), O(n), O(n∗log[n]), O(n²), O(2ⁿ), O(n!)순으로 효율적입니다.

---

## JS
###아래 코드의 시간 복잡도는 무엇일까요?

외부 반복문(for (let i = 1; i <= n; i++))은 n번 반복됩니다.
내부 반복문(for (let j = 1; j <= n; j *= 2))은 j를 2배씩 증가시키면서 n번 반복됩니다.
내부 반복문의 루프 횟수는 j가 1, 2, 4, 8, ..., n까지 2의 거듭제곱으로 증가하므로 log₂(n)번 반복됩니다.

따라서 전체 시간 복잡도는 외부 반복문과 내부 반복문의 곱으로 표현됩니다.

시간 복잡도: O(n * log₂(n))

###시간 복잡도를 코드가 동작하는 시간이 아니라, 연산 횟수를 측정하는 이유는 무엇일까요?

알고리즘의 상대적인 성능 평가

연산 횟수를 기반으로 하는 시간 복잡도는 알고리즘 간의 상대적인 성능을 평가하는 데 용이합니다. 어떤 알고리즘이 다른 알고리즘보다 적은 연산을 수행한다면, 일반적으로 입력 크기가 커질수록 해당 알고리즘이 더 효율적이라고 판단할 수 있습니다.

입력 크기에 따른 성장 패턴 확인

시간 복잡도를 연산 횟수로 측정하면 입력 크기에 따른 성장 패턴을 파악할 수 있습니다. 알고리즘의 시간 복잡도를 분석하면 입력 크기가 증가할 때 알고리즘이 어떻게 성능이 변하는지를 이해할 수 있습니다.

문제 해결 능력 확인

시간 복잡도를 연산 횟수로 표현하면 알고리즘의 문제 해결 능력을 좀 더 명확하게 이해할 수 있습니다. 어떤 알고리즘이 입력이 증가함에 따라 얼마나 빨리 문제를 해결할 수 있는지를 파악할 수 있습니다.
