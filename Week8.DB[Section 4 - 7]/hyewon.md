## MIZ

### DBMS는 Index를 어떻게 관리하고 있나요? (Index 자료구조)

DBMS는 인덱스를 해시 테이블, B-Tree, B+Tree로 관리하고 있습니다. Key를 사용하여 원하는 자료에 빠르게 접근하는 자료구조로 가장 먼저 떠오르는 것은 해시 테이블입니다. 해시 테이블은 Key-Value 쌍으로 데이터를 저장하는 자료구조입니다. 해시 테이블의 데이터는 정렬되어 있지 않으므로 원하는 데이터를 찾기 위해서는 모든 데이터에 접근 해야 합니다. 그렇기에 데이터베이스에 적합한 자료구조는 아닙니다. B-Tree는 메모리에 담기 어려운 큰 크기의 데이터를 다루기 위해 사용됩니다. 파일 시스템 혹은 데이터베이스에 적합합니다. B-Tree는 이진 탐색 트리의 일반화된 형태이며 자식 노드가 2개 이상인 트리입니다. 그러므로 노드의 개수를 늘리고 트리의 전체 높이를 줄여서 빠른 탐색 속도를 얻을 수 있습니다. B+Tree는 B-Tree를 개선시킨 자료구조입니다. 실제로 많은 DBMS에서 B+Tree를 사용합니다. 이는 오직 리프 노드의 키만 실제 데이터의 물리적 위치를 가리키고 있는 데이터 포인터를 가지고 있습니다. 그러므로 노드에 더 많은 키를 보관할 수 있습니다. 이는 곧 트리의 높이가 낮아지는 것을 의미하고 탐색 속도가 향상됨을 의미합니다. 또한, 순차 검색에 유리합니다.

### inner join과 outer join의 차이를 설명해주세요.

inner join은 내부 조인으로 왼쪽 테이블과 오른쪽 테이블의 두 행이 모두 일치하는 행이 있는 부분만 표기합니다. 즉, 두 테이블 간에 교집합을 나타내는 것이죠. outer join은 왼쪽 조인, 오른쪽 조인, 합집합 조인이 있습니다. 왼쪽 조인은 left outer join으로 왼쪽 테이블의 모든 행이 결과 테이블에 표기됩니다. 오른쪽 조인은 right outer join으로 오른쪽 테이블의 모든 행이 결과 테이블에 표기됩니다. 합집합 조인, 완전 외부 조인은 full outer join으로 두 개의 테이블을 기반으로 조인 조건에 만족하지 않는 행까지 모두 표기합니다.

---

## js

### 중첩 루프 조인에 대해 설명해 주세요.

중첩 루프 조인은 중첩 for문과 같은 원리로 조건에 맞는 조인을 하는 방법입니다. 2개 이상 테이블에서 하나의 집합을 기준으로 순차적으로 상대방 row를 결합하여 원하는 결과를 조합하는 조인 방식입니다. 랜덤 접근에 대한 비용이 많이 증가하므로 대용량의 테이블에서는 사용하지 않고 조인해야할 데이터가 많지 않은 경우에 유용하게 사용됩니다. 중첩 루프 조인은 선행 테이블의 결과를 통해 후행 테이블을 액세스 할 때 랜덤 I/O가 발생합니다.

### 정렬 병합 조인에 대해 설명해 주세요.

정렬 병합 조인은 각각의 테이블을 조인할 필드 기준으로 정렬하고 정렬이 끝난 이후에 조인 작업을 수행하는 조인입니다. 조인할 때 쓸 적절한 인덱스가 없고 대용량의 테이블들을 조인하고 조인 조건으로 범위 비교 연산자가 있을 때 씁니다. 조회의 범위가 많을 때 주로 사용하는 조인 방법론입니다. 연결 고리에 인덱스가 전혀 없는 경우, 대용량의 자료를 조인할 때 유리한 경우, 앞서 말한 범위 비교 연산자가 사용된 경우, 인덱스 사용에 따른 랜덤 액세스의 오버헤드가 많은 경우에 사용됩니다.

---

## yeop222

### 인덱스에 대해서 설명해주세요(정의, 필요성)

인덱스는 테이블 안에 내가 찾고자 하는 데이터를 빠르게 찾을 수 있는 하나의 장치입니다. 인덱스는 데이터베이스에서 테이블의 검색 성능을 높여주어 검색 속도를 향상시킵니다. 테이블의 데이터는 순서 없이 쌓이게 되므로 특정 조건의 데이터를 찾으려면 테이블의 모든 데이터에 접근하여 비교하는 과정이 필요합니다. 그렇기에 검색 속도 및 성능을 향상시키는 인덱스가 필요합니다.

### 인덱스는 매 필드마다 설정하는 것이 좋을까요?

인덱스를 매 필드마다 설정하는 것은 비효율적입니다. 인덱스는 두 번 탐색하도록 강요하므로 관련 읽기 비용이 많이 들게 됩니다. 또한, 컬렉션이 수정되었을 때 인덱스도 수정되어야 합니다. 또한, 인덱스의 저장 공간은 데이터베이스 전체 공간의 약 10%라고 합니다. 그러므로 잘못 사용하면 불필요한 저장 공간을 낭비하게 됩니다.
