# KJS님 질문

### KJS > 특정 언어가 일급 객체 라는 특징을 지닐 때, 일급 객체의 특징 3가지를 설명해주세요.

dog 답변:

1. 무명의 리터럴로 생성할 수 있다

-   arr.map( (res)=> {res});

2. 변수나 자료구조(객체,배열)등에 저장할 수 있다.

-   method, [1,1+2] => [1,3];

3. 함수의 매개변수에 전달할 수 있다.

-   f(a) => (f) => f.age < 14;

4. 함수의 반환값으로 사용할 수 있다.

-   const result = () => console.log(1);
    result 는 무명 함수의 반환 값 console.log(1);을 할당받는다.

### KJS >> 함수형 프로그래밍의 특징 중 불변성에 대해 설명 해주세요

dog 답변:

-   함수형 프로그래밍의 ‘불변성’이란 제 질문에서 답변으로 썻던 예시코드로 예를 들 수 있습니다.
    함수형 프로그래밍에서 불변성이란 메모리에 저장된 값을 변경하는 모든 행위를 의미합니다.
    결국 불변성이란 데이터가 유동적으로 변하지 않아야하며 한번 정의한 데이터는 그 데이터를 가리키는 식별자의 의미에 맞게 데이터가 보존되어야 하며
    이를 지키기위해 함수형 프로그래밍에서는 새로운 값을 반환한다는 의미를 가지고 있습니다.
    새로운 데이터는 그에 맞는 새로운 식별자에 할당함으로 데이터의 고유성을 지킨다는 것이죠.

-   어떤 값이든 데이터를 변경하는게 아니라 새로운 데이터를 반환함으로 데이터의 불변성을 지킵니다.
    이는 자유분방한 자바스크립트의 일급 객체 === 함수 라는걸 이용해 자바스크립트의 자유분방함을 장점으로 활용한 것이라고 볼 수 있습니다.

-   함수 내부에 데이터를 할당하는 방식을 함수에 위임함으로써 내부에 데이터를 기존에 값에서 변경하는게 아닌
    return — 을 통해 새롭게 반환해 식별자에 맞는 데이터를 할당해 데이터의 불변성을 지킨다라고 생각합니다.

이 질문에 대한 답을 하면서 이것도 결국 자유분방한 자바스크립트에 치명적인 단점을 보완하기 위한 방식으로
장점 **( 어떤 상황이느냐에 따라 장점으로, 단점으로 작용할 수도 있겠지만 )** 을 극대화해 단점을 극복한 프로그래밍 패러다임 같다는 생각이 들었습니다.

# MIJI님 질문

### MIJI님 질문 > 객체 지향 프로그래밍이 무엇이며 이것의 장, 단점을 간단하게 설명해주세요

dog 답변:

-   객체지향 프로그래밍은 객체들의 집합으로 프로그램의 상호 작용을 표현하며 데이터를 객체로 취급하여 객체 내부에 선언된 메서드를 활용하는 방식을 말합니다. 설계에 많은 시간이 소요되며 처리 속도가 다른 프로그래밍 패러다임에 비해 느리다는 단점이 있습니다.

### MIJI님 질문 > 객체 지향 프로그래밍의 키워드를 3가지 이상 말하고 그 중 하나에 대해 무엇인지 설명해주세요.

dog 답변:

-   캡슐화,상속,다형성
    제가 셋 중에 그나마 말할 수 있는건 캡슐화 같은데요
    캡슐화는 객체의 상태와 행위를 하나로 묶고 외부에서 접근할 수 있는 인터페이스를 제공함으로써 객체 내부의
    복잡한 동작을 감추는것을 의미합니다.

-   자바스크립트에서도 캡슐화의 private같은 접근 제어자를 추진합니다.
    ECMAScript에 정식적으로 올라오진 않았지만 평가 중이기도 하구요.2021년 처음 평가 기준에 올라왔지만 아직 정식적으로 발표가 나오진 않았습니다.

-   솔직히 잘 모르겠습니다. 아직 저는 서버에서 외부에서 접근할 수 있는 인터페이스를 제공함으로써 객체 내부의 복잡한 동작을 감춘다
    라는 의미는 사용자가 내부 동작을 알기 위해 접근을 제어한다는 의미로 저는 해석했습니다.
    그 의미에 따라 보안성에서 긍정적인 영향을 끼친다는건 알겠습니다만 제가 직접 다뤄보지 못했습니다.
    하지만 바닐라 자바스크립트로 클로저를 통해 private 와 같이 접근제어자를 구현할 수 있습니다만..

-   하지만 클라이언트의 내부 로직은 개발자 환경으로 사용자가 추적해낼 수 있어 제 경험으로 클라이언트 한에 직관적으로 이해할 수 있습니다만
    서버를 어떻게 해커가 털어내는지 그에 대한 지식이 많이 부족해서 추 후에 더 공부해서 알아봐야할 것 같습니다.

# hyewonk815 님 질문

### hyewonk815님 질문 > 함수형 프로그래밍의 장단점에 대해서 설명해주세요.

dog 답변:

-   함수형 프로그래밍의 장점은 유연성,불변성 이고 단점은 가독성이 좋지 않고, 학습 곡선이 높아 이해도가 낮으면 해석하기도 다루기도 어렵다고 느꼈습니다.

### hyewonk815님 질문 > 객체지향 프로그래밍은 설계할 때 SOLID 원칙을 지켜주어야 하는데요. SOLID에 대해서 간단하게 설명해주세요.

dog 답변:

-   solid원칙이란 s는 단일책임 원칙, O는 개방-폐쇠 원칙, l은 리스코프 치환 원칙, I는 인터페이스 분리원칙, D는 의존 역전 원칙입니다.

# yeop222 님 질문

### yeop222님 질문 > 절차지향 언어의 장, 단점에 대해 설명해주세요.

dog 답변:

-   절차지향언어의 장점은 코드가 직관적이며 병렬적으로 처리가되서 대규모에 시스템에서 성능으로 높일 수 있으며 코드의 순서,흐름을 파악하는데 쉽습니다.
    단점은 전역변수를 많이 사용하게 되기 때문에 메모리관리에 신경써야합니다.
    또 재사용성이 떨어지며 전역 변수를 많이 사용한다는것은 데이터가 유동적으로 바뀔 수 있는 실수가 있을 수 있습니다.
    크롬앱 클론코딩에서 dom을 자바스크립트로 가져오는 과정에서 전역변수를 많이 선언하는것과 같다고 생각했습니다.
    이러한 단점을 극복하기 위해 객체지향 프로그래밍이 등장하게 되었다고 생각합니다.

### yeop222님 질문 > 객체 지향 언어와 절차 지향 언어의 차이점에 대해 간단히 설명해주세요.

dog 답변:

-   단순히 DOM을 객체의 프로퍼티에 할당해서 생각을 해봤는데요
    전역 변수는 전역 스코프에서 변수가 유지되기 떄문에 메모리 누수가 일어날 수 있습니다.
    하지만 객체의 프로퍼티로 할당하게되면 객체 내부에서만 사용되기 떄문에, 메모리 누수의 위험은 적고
    해당 객체를 참조하는 변수를 통해 DOM요소에 접근할 수 있기 떄문에 유지보수, 가독성 측면에서 장점을 가져갈수 있을 것 같습니다.
-   좀 더 부연설명을 해보자면 전역 변수로 메모리 누수를 방지하기위해 null로 할당하였다면
    전역 변수는 전역 스코프에서 유지되기 때문에 전역 변수를 Null로 할당하더라도 그 변수를 참조하고 있는 다른 코드에서
    여전히 사용될 가능성이 있습니다.

-   객체로 선언되어 내부를 참조한다는것은 결국 객체 선언시에 메모리가 사용됨은 전역변수와 별 다른 차이가 없지만
    객체를 전역에 선언하더라도 객채 내부의 프로퍼티를 사용할 때 그 프로퍼티가 사용할 때에만 메모리 사용이 이뤄지기 때문에
    전역 객체를 선언하면서 객체선언에 따른 메모리는 사용될 수 있어도 프로퍼티에 할당된건 그 내부 프로퍼티를 사용할 때에
    메모리를 사용한다고 볼 수 있습니다.

-   그럼 사용되는 프로퍼티가 사용을 다 했을 시 null로 비워준다면 가비지 콜렉터에의해 참조되는 어떤 요소도 없을 경우 메모리를 관리하기
    용이할것같습니다.

객체지향 프로그래밍을 해본적이없어 최대한 경험에대한 예시로 들어봤습니다.
이런 이유로 점점 이유들이 확장돼 객체지향 프로그래밍이 탄생한게 아닐까 라는 생각이 들었습니다.

# dog질문

### dog 질문 > 객체지향 프로그래밍언어 (클래스기반 java,C), 프로토타입기반 프로그래밍언어의 차이점은 (javascript)?

dog 답변 :  
(객체지향 프로그래밍 언어를 제대로 다뤄본적이 없어 자바스크립트를 기준으로 설명했습니다 참고 부탁드립니다.)

프로토타입 기반 객체지향이란
자바스크립트가 탄생한 이유와 밀접한 관련이 있다고 생각합니다.
초기 자바스크립트는 누구나 쉽게 배우고 빠르게 작업할 수 있게 데이터 형식이나 class 등
정적 언어에서 지원하던 중요한 설계를 빼고 빠르게 만들었습니다.

결국 프로토타입 기반 객체지향이란 점차 비대해지는 자바스크립트가 다른 언어들처럼
‘안정성’에 필요성을 느껴 점점 그들과 유사해지기 위해 겪은 성장통입니다.

자바스크립트는 ES6+ 부터 클래스를 지원합니다.
결국 이 클래스도 프로토타입 기반 객체지향이기 떄문에 class라는 문법적 설탕을 적용했습니다.

클래스를, 프로토타입을 지나쳐 배우게 된다면 이런 자바스크립트의 고유의 특성을 이해하지 못하게 됩니다.
또한 클래스를 사용하면 프로토타입 기반의 객체 지향 프로그래밍에서 사용되는 프로토타입 체인과 같은 개념을 이해하지 못하고
클래스만으로 객체지향 프로그래밍을 이해하려는 경향이 있습니다. 따라서 클래스를 사용하면서도 자바스크립트의 고유한 특성을 이해하고 활용할 수 있어야 합니다.

프로토타입기반과 다른 언어에서 쓰이는 OOP는 완전히 상반되는 방식입니다.

자바스크립트는 프로토타입(원형)을 중심으로 this가 가리키는 곳이 달라집니다.
(일반 함수로 호출했느냐, 화살표 함수에 This를 사용했느냐, 원형이 누가오느냐)

OOP기반 프로그래밍 언어에서는 this는 항상 객체 자신을 가르킵니다.
this를 쓰지않아도 OOP기반 프로그래밍 언어에서는 프로퍼티가 자신이 생성할 인스턴스를 this에 바인딩합니다.

Object란 물체입니다. OOP기반은 물체를 변동하지 않습니다. 가리키는 대상이 ‘인물’이면 인물에 대한 추상만합니다.

프로토타입 객체기반은 조금 다르게 접근합니다. ProtoType이란 원형이라는 뜻을 가지고 있습니다.
원형이란 ‘같거나 비슷한 여러 개가 만들어져 나온 본바탕’ 이라는 뜻을 가지고 있는데요,

프로토타입과 OOP기반의 가장 큰 핵심은 ‘물체’와, ‘비슷한 여러개’ 입니다.

프로토타입이란 의미사용이론과 유사합니다
‘사용’에 의해 ‘의미’가 결정된다는 이론입니다.
즉, 단어의 진정한 본래의 의미란 존재하지 않고 ‘상황’과 ‘맥락’에 의해서 결정됩니다.

프로토타입 메서드는 기본적으로 obj.__proto__.method 즉 원형의 의미가 상황과 맥락에 의해 결정됩니다.

벽돌을 예로 들면 누군가 "멈춰!"라 외쳤을 때 상황마다 그 의미는 달라집니다.

길을 건너는데 차가 빠른속도로 지나갈 때 : 차가 달려오니까 멈춰라.

경찰이 도둑을 추격할 때 : 그만 도망가고 그 자리에 멈춰라.

누군가 위험한 행동을 할 때 : 그 행동을 멈춰라.

멈춰라는 의미는 똑같을지 몰라도 그 앞에 처한 상황에 따라 의미가 바뀐다는 것입니다.

결국 프로토타입 기반 객체지향이란 의미사용이론에 따라 어떤 상황에 접했느냐에 따라 의미가 달라지는
프로토타입 언어에서는 ‘분류’를 우선하지 않고 생성된 객체 위주로 유사성을 정의합니다.
어휘, 쓰임새는 맥락(context)에 의해 평가되며 실행 컨텍스트, 스코프 체인이 여기서 파생되었습니다. 클로져, this, 호이스팅 등등. 이 모든 헬(?) 이 프로토타입의 ‘맥락’을 표현하기 위한 것입니다.

초기 작고 자유분방 했던 자바스크립트의 사용성에 대한 역사적인 흐름이라고 말할 수 있습니다.

클래스기반 객체지향이란 안정성을 무엇보다 추구하는, 큰 규모에서 빛을 발하던 C,Java와 같은 언어들이
‘추상’에 접근할 때 안전하고 그에 따라 유연하게 추상하기 위한 것 이라고 생각합니다.

즉 클래스 기반 객체지향은 ‘안정성’을 위주로 객체를 생성해 추상화,
프로토타입 기반 객체지향은 ‘안정성’을 추구하며 동시에 유연성을 강조하는, 예전의 것을 가지고 최대한 객체지향 언어의 쓰임새에 맞게
필요성에 따라 추가된 방식 이라고 볼 수 있겠습니다.

### dog 질문 > 함수형 프로그래밍은 표현식을 함수에 위임하여 내부 로직을 변경하지 않고도 표현식을 유동적으로 바꿀 수 있어

유연하게 로직을 변경할 수 있고, 유지보수에 용이합니다. 표현식을 함수에 위임한다는건 무엇일까요?

일반적으로 절차지향이라고 하는 방식은 값을 기존의 배열,객체에 넣을 때 이런식으로 구현할 수 있습니다. let v = []; for(const a of pr) {  v.push(a);
} conosle.log(v);

함수형 프로그래밍에서 표현식을 함수에 위임하다는것은 함수를 값으로 사용함으로 써 함수가 리턴되는 값을 유동적으로 표현식으로 쓸 수 있다는것인데요.

const products = [
{name: ‘아무개’, age:14},  {name:’홍길동’, age:25},
{name: ‘구준표’,age:18},
]

이런 products가 있다고 가정했을 때 map 함수를 만들어볼텐데


const map = (f,i) => {
let v = [];
for(const a of i) {
v.push(f(a))
}
};

console.log(map( a => a.name, products));
// 아무개, 홍길동, 구준표

내부로직을 변경하지 않고 값을 결정하는 표현식을 함수에 위임함으로 서 유연하게 배열에 담는 값을 필요에 따라 담을 수 있습니다.

- 참고자료 [protoype](https://medium.com/@limsungmook/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EB%8A%94-%EC%99%9C-%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85%EC%9D%84-%EC%84%A0%ED%83%9D%ED%96%88%EC%9D%84%EA%B9%8C-997f985adb42)
모던 자바스크립트 딥 다이브,

모던 자바스크립트 web,

코파일럿,

그 외 스처간 수 많은 블로그들...
